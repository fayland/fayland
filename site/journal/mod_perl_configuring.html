<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="../style/journal.css" type="text/css" />
<style type="text/css"><!--
.googleadsense {
	margin: 2px;
	padding: 0px;
//--></style><script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-65008-1";
urchinTracker();
</script><title>mod_perl 配置的一些指令</title>
</head>
<body>
<a href="index.html">Journal</a>(2005) | <a href="../blog/"><b>Blog</b></a>(2006) | <a href="http://www.fayland.org/cgi-bin/random_link.pl">RandomLink</a> | <a href="AboutFayland.html">WhoAmI</a> | <a href="LiveBookmark.html">LiveBookmark</a> | <a href="http://www.fayland.org/">HomePage</a>
<p><&lt;Previous: <a href="mod_perl_learning.html">a schedule of mod_perl learning</a>&nbsp;&nbsp;>>Next: <a href="CPAN_update.html">CPAN RSS updated</a></p>
<h1>mod_perl 配置的一些指令</h1>
<div class='content'>
<p>Category: <a href='mod_perl.html'>mod_perl</a> &nbsp; Keywords: <b>mod_perl configuring</b></p>第一句见的最多的可能是 PerlModule<h3>PerlModule</h3>PerlModule Foo::Bar 就等同于 Perl 的 require Foo::Bar;<br />有点不同的可能是可以接受多个参数：PerlModule Apache::DBI CGI DBD::Mysql<br />如果你需要传递 qw/foo bar/ 给 Foo::Bar 的话，一般将它写入一个 pl 文件里，然后用 PerlRequire 载入它。如 startup.pl:<br /><pre>use Apache2::Const -compile => ':common';<br />use APR::Const -compile => ':common';<br />...<br /></pre><h3>PerlRequire</h3>在 1.0 中在这是常用句，用于载入一个 Perl 文件。由于它不能控制代码的运行时间，所以在 2.0 中被  PerlConfigRequire 和 PerlPostConfigRequire 所细分。<br />PerlConfigRequire 是碰到该语句立即运行该参数文件，而 PerlPostConfigRequire 是在服务器运行的最后阶段才运行。<br />一般而言，PerlPostConfigRequire 才是我们所要的。<br /><pre>PerlRequire "C:/Apache2/conf/startup.pl"</pre><h3>PerlOption</h3>提供 mod_perl 的编译选项。<br />如果在运行时需要确定某些选项是否已经启用，可使用 $r->is_perl_option_enabled($option) 或 $s->is_perl_option_enabled($option) 来判断。<br />一般允许用 +, 禁止用 -<h4>Enable</h4>一般用于使某虚拟主机能用，而某主机不能使用 mod_perl. 如<br /><pre>&lt;VirtualHost ...><br />    PerlOptions -Enable<br />&lt;/VirtualHost></pre><h4>Perl*Handler</h4>可以设置哪些 Perl*Handler 我们能使用而哪些不能使用。如<br /><pre>&lt;VirtualHost ...><br />    PerlOptions -Authen -Authz -Access -Sections<br />&lt;/VirtualHost></pre>就禁止使用 PerlAuthenHandler, PerlAuthzHandler, PerlAccessHandler, 和 <Perl> Sections/段。而<br /><pre>&lt;VirtualHost ...><br />    PerlOptions None +Response<br />&lt;/VirtualHost></pre>就只能使用 PerlResponseHandler<h4>AutoLoad</h4>大致是自动加载的意思。比如开启 PerlOptions +Autoload 后，当使用 PerlResponseHandler Apache::Magick 时前面就不需要先明显的加载 PerlModule Apache::Magick 模块。而是碰到后会自动加载。<h4>ParseHeaders</h4>它与 mod_perl 1.0 中的 PerlSendHeader On 功能一样。<br />如果你在代码中使用 print "Content-type: text/html\n\n"; 的话将这个 PerlOption 开起来。它会将这句话自动转为调用 send_http_header<br />这一般在 <a href="http://search.cpan.org/perldoc?ModPerl::Registry">ModPerl::Registry</a> 中用得比较多。因为 ModPerl::Registry 使用的旧代码都是这么输出的。<br /><pre>&lt;Location /perl><br />  SetHandler perl-script<br />  PerlResponseHandler ModPerl::Registry<br />  Options +ExecCGI<br />  PerlOptions +ParseHeaders<br />  PerlOptions +SetupEnv<br />&lt;/Location></pre><h4>Others etc.</h4>还有一些其他比较复杂的涉及到编译池或环境变量什么的。如果以后有机会用到再介绍。<h3>PerlSwitches</h3>Switch 的意思是开关。如我们在命令行时会使用 perl -e 这里的 -e 就是一个 switch.<br />一般而言它最大的用途就是修改 @INC, （我们也可以在 startup.pl 里修改，然后 PerlRequire）用 PerlSwitches 的好处就是黏合力更强一些。如：<br /><pre>PerlSwitches -I/var/www/MyApp/lib</pre>它的作用还类似于这么写：<br /><pre>&lt;Perl><br />    use lib qw(/var/www/MyApp/lib);<br />&lt;/Perl></pre>这三种办法都是可以的。<h3>SetHandler</h3>有两种类型，一种是 <a href="http://perl.apache.org">modperl</a>, 另一种是 perl-script<h4>perl-script</h4>这是更为常见的类型的。它的默认配置为：<ul><br /><li>如果没有 PerlOptions -GlobalRequest 的话，PerlOptions +GlobalRequest 将在 PerlResponseHandler 阶段起作用。<br /><li>如果没有 PerlOptions -SetupEnv 的话，默认将是 PerlOptions +SetupEnv<br /><li>将 STDIN 和 STDOUT 与 $r 绑定，这样就能使用 CORE::print() 来输出到 STDOUT 或从 STDIN 中读取。而 modperl 类型必须使用 $r->puts() 这样的函数来输出。<br /><li>%ENV, @INC, $/, STDOUT 的 $| 和 END 块这种特殊变量将在调用 response handler 之前保存而在之后将恢复。<br /><li>任何加到 %ENV 的变量将传递给 subprocess_env 表，而后我们可以在接下来的 PerlLogHandler 和 PerlCleanupHandler 阶段中通过 r->subprocess_env 来获取。<br /></ul><h4>modperl</h4>这种类型下你只能调用 Perl*Handler 里的函数。如果你不需要以上 perl-script 的用途的话，使用 modperl 会带来更好的性能。<br />当配置成 PerlOptions +SetupEnv 时， modperl 类型只配置如下环境变量：$ENV{MOD_PERL}（总是存在） $ENV{PATH} 和 $ENV{TZ} （如果你在命令行/shell 或 httpd.conf 里设置了它们）。这时候你如果想传递一些配置变量的话一定要使用 PerlSetVar 和 PerlAddVar 而不是 PerlSetEnv 和 PerlPassEnv. 举一个例子：<br /><pre> #httpd.conf<br />&lt;Location /print_env2><br />   SetHandler modperl<br />   PerlResponseHandler Apache2::VarTest<br />   PerlSetVar VarTest VarTestValue<br />&lt;/Location></pre>接下来在 Apache2::VarTest::handler() 里你可以通过<br /><pre>$r->dir_config('VarTest');</pre><h4>例子</h4><pre>file:MyApache2/PrintEnv1.pm<br />-----------------------<br />package Apache::PrintEnv1;<br />use strict;<p />use Apache::RequestRec ( ); # for $r->content_type<br />use Apache2::RequestIO ();  # for print<br />use Apache2::Const -compile => ':common';<p />sub handler {<br />      my $r = shift;<br />  <br />      $r->content_type('text/plain');<br />      for (sort keys %ENV){<br />          print "$_ => $ENV{$_}\n";<br />      }<br />  <br />      return Apache2::Const::OK;<br />  }<br />1;</pre>这个需要配置成<br /><pre>PerlModule MyApache2::PrintEnv1<br />&lt;Location /print_env1><br />   SetHandler perl-script<br />   PerlResponseHandler MyApache2::PrintEnv1<br />&lt;/Location></pre><pre>file:MyApache2/PrintEnv2.pm<br />------------------------<br />package MyApache2::PrintEnv2;<br />use strict;<br />  <br />use Apache2::RequestRec (); # for $r->content_type<br />use Apache2::RequestIO ();  # for $r->print<br />  <br />use Apache2::Const -compile => ':common';<br />  <br />sub handler {<br />      my $r = shift;<br />  <br />      $r->content_type('text/plain');<br />      $r->subprocess_env;<br />      for (sort keys %ENV){<br />          $r->print("$_ => $ENV{$_}\n");<br />      }<br />  <br />      return Apache2::Const::OK;<br />}<br />1;</pre>这个可以配置成<br /><pre>PerlModule MyApache2::PrintEnv2<br />&lt;Location /print_env2><br />    SetHandler modperl<br />    PerlResponseHandler MyApache2::PrintEnv2<br />&lt;/Location></pre><ul>不同点：<br /><li>perl-script 可以用 print, 而 modperl 只能用 $r->print<br /><li>perl-script 默认就用 PerlOptions +SetupEnv, 而 modperl 下一定要显性调用 $r->subprocess_env; 或开启 PerlOptions +SetupEnv<br /></ul><h3>PerlResponseHandler</h3>这个阶段是用于创建回复的。这毫无疑问是 mod_perl 中最最重要的阶段。<br />而且这个指令是 mod_perl 中<b>必须</b>的两个指令之一。<br /><pre>&lt;Location /hello><br />  SetHandler perl-script<br />  PerlResponseHandler Apache2::Hello<br />&lt;/Location></pre>哪个指令都能少，就这两个是必须的。它指出了在 ResponseHandler 阶段所委托的模块。<h3>Reference</h3>* <a href="http://perl.apache.org/docs/2.0/user/config/config.html">http://perl.apache.org/docs/2.0/user/config/config.html</a></div></div>
<p><&lt;Previous: <a href="mod_perl_learning.html">a schedule of mod_perl learning</a>&nbsp;&nbsp;>>Next: <a href="CPAN_update.html">CPAN RSS updated</a></p>
<p><strong>Options:</strong> <a href='http://del.icio.us/post?title=mod_perl%20%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4&url=http://www.fayland.org/journal/mod_perl_configuring.html'>+Del.icio.us</a></p>
<strong>Related items</strong>
<ul><li><a href='mod_perl_learning.html'>a schedule of mod_perl learning</a> < <span class='digit'>2005-11-12 21:53:55</span> ></li></ul>
Created on <span class="digit">2005-11-13 11:38:05</span>, Last modified on <span class="digit">2005-11-23 23:00:46</span><br />
Copyright 2004-2005 All Rights Reserved. Powered by <a href="Eplanet.html">Eplanet</a> && <a href='http://catalyst.perl.org'>Catalyst</a> 5.62.
</body>
</html>